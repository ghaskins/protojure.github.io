# Protojure

Protojure is first-class [Clojure](https://clojure.org/) support for
[Protocol Buffers](https://developers.google.com/protocol-buffers/) and [gRPC Services](https://grpc.io/)

[https://github.com/protojure](https://github.com/protojure)

## Features

* Supports Protobuf message serialization (tested with proto3 format)
* Support for GRPC Clients and Servers
* In-process [GRPC-WEB](https://github.com/grpc/grpc-web) Proxy
* core.async based GRPC streaming
* Integration with the [Pedestal](https://github.com/pedestal/pedestal) web framework included, and extensible to support others (Ring, Compojure, etc)

## Etymology

Protojure is a portmanteau of **Proto**-col Buffers and Clo-**jure**

## Table of Contents

* [Installation](#installation)
* [Quick Start](#quick-start)
* [Protocol Buffers in clj](#protocol-buffers-in-clj)
* [gRPC Services in clj](#grpc-services-in-clj)
* [Unary Endpoint Examples](#unary-endpoint-example)
* [Streaming Examples](#server-streaming-example)
* [Clojure Docs](#clojure-docs)
* [Contributing](#contributing)

## Installation

As a first step to follow along with the tutorials here, please clone
[protoc-plugin](https://github.com/protojure/protoc-plugin) and run
```
make bin
make install
```

Note that make install will place the protoc-plugin binary in /usr/local/bin. Ensure /usr/local/bin is in your PATH
env var, or move the binary to an appropriate location.

This and all following steps rely on the presence of a jdk and [Leiningen](https://leiningen.org/)

## Quick Start

### Quick Start Prerequisites:
1. [Leiningen](https://leiningen.org/)
2. [Protoc](https://github.com/protocolbuffers/protobuf/releases/tag/v3.9.1)

### Quick Start Guide:

Run `lein new protojure <your project name>`

This instantiates a leiningen template that creates a
runnable application hosting gRPC endpoints.

Refer to the README.md in the created project for instructions on how to use your
own `.proto` Protocol Buffer and gRPC Service definitions.

## Protocol Buffers in clj

Below is a simple [`.proto`](https://developers.google.com/protocol-buffers/) Protocol Buffer (protobuf or pb) definition:

```
syntax = "proto3";
package com.example.addressbook;

message Person {
    string name = 1;
    int32 id = 2;  // Unique ID number for this person.
    string email = 3;

    enum PhoneType {
        MOBILE = 0;
        HOME = 1;
        WORK = 2;
    }

    message PhoneNumber {
        string number = 1;
        PhoneType type = 2;
    }

    repeated PhoneNumber phones = 4;
}

message AddressBook {
    repeated Person people = 1;
}

```

Given the above contents in a file, `addressbook.proto`, in our current directory, we may use the protojure
[protoc plugin](https://github.com/protojure/protoc-plugin) to generate .clj language bindings:
```
mkdir src/
protoc --clojure_out=src/ addressbook.proto
```

After running the above, we will find a nested directory structure corresponding to the package above
(`com.example`):

```

$ cat src/com/example/addressbook.clj
;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; Message Implementation of package com.example.addressbook
;;;----------------------------------------------------------------------------------
...
..
. <File contents continues -- run the `cat` command above to see your generated output in full>
```

We can create a `project.clj` file alongside our `.proto` file:
```
(defproject protojure-tutorial "0.0.1-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Apache License 2.0"
            :url "https://www.apache.org/licenses/LICENSE-2.0"
            :year 2019
            :key "apache-2.0"}
  :dependencies [[org.clojure/clojure "1.10.1"]

                 ;; -- PROTOC-GEN-CLOJURE --
                 [protojure "1.1.0"]
                 [com.google.protobuf/protobuf-java "3.11.1"]])

```

Now, running `lein repl`:

```
$ lein repl
nREPL server started on port 35997 on host 127.0.0.1 - nrepl://127.0.0.1:35997
WARNING: cat already refers to: #'clojure.core/cat in namespace: net.cgrand.regex, being replaced by: #'net.cgrand.regex/cat
REPL-y 0.3.7, nREPL 0.2.12
Clojure 1.10.0
OpenJDK 64-Bit Server VM 1.8.0_222-8u222-b10-1ubuntu1~18.04.1-b10
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=> (use 'com.example.addressbook)
nil
```

We create clojure representations of protobuf messages by requiring the appropriate ns generated by the protojure protoc
plugin, as above, and then exercising the `new-<Pb-message-name-here` like so:

```
user=> (new-Person {:name "Jane Doe"})
#com.example.addressbook.Person{:name "Jane Doe", :id 0, :email "", :phones []}
```

We can then transform this in-memory clj representation to the protocol buffer bytes representation by requiring the
protojure.protobuf namespace from the protojure lib [protojure lib](https://github.com/protojure/lib):

```
user=> (require '[protojure.protobuf :as protojure])
nil
user=> (protojure/->pb (new-Person {:name "Jane Doe"}))
#object["[B" 0x11398205 "[B@11398205"]
```
For illustration purposes, here is the native java byte array in a clojure vector:
```
user=> (into [] (protojure/->pb (new-Person {:name "Jane Doe"})))
[10 8 74 97 110 101 32 68 111 101]
```
In order to deserialize an array of bytes, we use the `pb-><Message name here>` form from the generated code (here, our
ns `com.example.addressbook`):
```
user=> (pb->Person (byte-array [10 8 74 97 110 101 32 68 111 101]))
#com.example.addressbook.Person{:name "Jane Doe", :id 0, :email "", :phones []}
```

You've now round tripped a Protocol Buffer message from definition, to .clj language bindings, to in-memory
clj representation to bytes and back to the in-memory form!

## gRPC Services in clj

gRPC is a "high performance, open-source universal RPC framework".

For those without any prior gRPC experience, gRPC is a standardized way of communicating between processes, often over
a network, whether within a data center or across the wider internet.

Below is a simple [gRPC](https://grpc.io/) service definition:

```
syntax = "proto3";
package com.example.addressbook;

message Person {
    string name = 1;
}

message AddressBook {
    repeated Person people = 1;
}

message HelloResponse {
    string message = 1;
}

service Greeter {
    rpc Hello (Person) returns (HelloResponse);
}

```

The service definition defines an endpoint (often reachable at some well-known URL or IP), called Greeter. The Greeter service
exposes a method called Hello. We may interact with the Hello method by contacting the Greeter service and sending
a Person message. Refer to [Protocol Buffers in clj](#protocol-buffers-in-clj) above for a walkthrough of protobuf
with protojure.

The message definition of HelloResponse is just like the `message Person` definition discussed in the previous section.

For our next steps, first open a new terminal and run:

```
lein new protojure demo-server
cd demo-server && make all
lein run
```

Alternatively, refer to and run the[`hello` example](https://github.com/protojure/protoc-plugin/tree/master/examples/hello) from the
[Protojure protoc-plugin](https://github.com/protojure/protoc-plugin/tree/master/examples/hello).

Note: Whichever approach is used, its important to ensure that the `.proto` in your server matches the .proto above (or
vice versa). The `.proto` defines the ABI contract for any client or server.

Open a separate terminal from the one running your server, cd to a directory of your choice and copy the contents of the
`.proto` in the resources/ directory of your server to your current directory:

```
cp <path to>/demoserver/resources/addressbook.proto .
```

Assuming you're using the lein-template demo-server created by `lein new protojure demo-server`, the contents of the
`.proto` will begin with:

```

syntax = "proto3";
package com.example.addressbook;

message Person {
...
```

Now, run:
```
protoc --clojure_out=grpc-client:. greeter.proto
```

If we check the contents of our directory, we will now also see a folder called `com/`. Inside is our generated gRPC
client code.

If we create another file called `project.clj` in our current directory with contents:

```
(defproject protojure-tutorial "0.0.1-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Apache License 2.0"
            :url "https://www.apache.org/licenses/LICENSE-2.0"
            :year 2019
            :key "apache-2.0"}
  :dependencies [[org.clojure/clojure "1.10.1"]

                 ;; -- PROTOC-GEN-CLOJURE --
                 [protojure "1.1.0"]
                 [com.google.protobuf/protobuf-java "3.11.1"]
                 ;; -- PROTOC-GEN-CLOJURE HTTP/2 Client Lib Dependency --
                 [org.eclipse.jetty.http2/http2-client "9.4.17.v20190418"]]
  :source-paths ["."])



```
save it, open a repl and try to `use` the generated namespace, we will see output similar to the below:
```
$ lein repl
nREPL server started on port 34903 on host 127.0.0.1 - nrepl://127.0.0.1:34903
WARNING: cat already refers to: #'clojure.core/cat in namespace: net.cgrand.regex, being replaced by: #'net.cgrand.regex/cat
REPL-y 0.3.7, nREPL 0.2.12
Clojure 1.10.0
OpenJDK 64-Bit Server VM 1.8.0_222-8u222-b10-1ubuntu1~18.04.1-b10
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=> (require '[com.example.addressbook.Greeter.client :as greeter])
WARNING: take already refers to: #'clojure.core/take in namespace: protojure.grpc.client.utils, being replaced by: #'protojure.grpc.client.utils/take
nil

```

We can see that one of the var's refer'd into our repl is `greeter/Hello`:
```
user=> greeter/He<Tab for auto complete options>
Hello
```

In order to invoke the client call, we'll need to create a client. We do this by requiring the protojure-lib ns below:
```
user=> (require '[protojure.grpc.client.providers.http2 :as grpc.http2])
nil
```
And creating a client connection:
```
user=> (def client @(grpc.http2/connect {:uri "http://localhost:8080"}))
#'user/client
```
Note: Many calls in the SDK return a [promise](https://clojuredocs.org/clojure.core/promise) and we therefore
[deref](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/deref) the calls to make them synchronous
for illustration purposes.

Now we can use our `Hello` function from above, and with the protoc-plugin example `hello` running we will receive
a HelloResponse message (you can see this message defined in the `greeter.proto` content above):
```
user=> @(greeter/Hello client {:name "Janet Johnathan Doe"})
#com.example.addressbook.HelloResponse{:message "Hello, Janet Johnathan Doe"}

```

In the logs of the running protoc-plugin `hello` example we will see:

```
INFO  io.pedestal.http - {:msg "POST /com.example.addressbook.Greeter/Hello", :line 80}
```

With a utility like `tcpdump` or wireshark, we would also see packets on our local network between the repl and server.

Congratulations, you've invoked a remote procedure call round trip with the GRPC protocol using Clojure on both ends.
You may now interoperate with a client or server written in any other language that adheres to the GRPC and .proto spec.

## Further examples


### Clojure gRPC Client Connect Example

```
@(grpc.http2/connect {:uri (str "http://localhost:" port) :content-coding "gzip"})
```

#### Unary Endpoint Example
[Protocol Buffer Definition](https://github.com/protojure/protoc-plugin/blob/master/examples/hello/resources/addressbook.proto)
```
syntax = "proto3";
package com.example.addressbook;

message Person {
    string name = 1;
    int32 id = 2;  // Unique ID number for this person.
    string email = 3;

    enum PhoneType {
        MOBILE = 0;
        HOME = 1;
        WORK = 2;
    }

    message PhoneNumber {
        string number = 1;
        PhoneType type = 2;
    }

    repeated PhoneNumber phones = 4;
}

```
```
message HelloResponse {
    string message = 1;
}

```
* gRPC Service Definition
```
service Greeter {
    rpc Hello (Person) returns (HelloResponse);
}
```

* Client
```
@(greeter/Hello @(grpc.http2/connect {:uri "http://localhost:8080"}) {:name "Janet Johnathan Doe"})
```
* Server Handler

{% raw %}
```
(deftype Greeter []
  greeter/Service
  (Hello
    [this {{:keys [name]} :grpc-params :as request}]
    {:status 200
     :body {:message (str "Hello, " name)}}))
```
{% endraw %}

Include the below in the interceptors passed to
the pedestal routes key:

```
(proutes/->tablesyntax {:rpc-metadata greeter/rpc-metadata
                        :interceptors common-interceptors
                        :callback-context (Greeter.)})
```

Refer to [src/hello](https://github.com/protojure/protoc-plugin/tree/master/examples/hello/src/hello) in the hello example
in the `examples/` dir of protoc-plugin [here](https://github.com/protojure/protoc-plugin/tree/master/examples/hello)

You can find an additional unary client and server example (a runnable one) in the boilerplate generated by 'lein new protojure'

#### Server Streaming Example

Simply return a [core.async](https://github.com/clojure/core.async)
[channel](https://clojuredocs.org/clojure.core.async/chan) in the :body key returned by your interceptor handler
instead of a map as above in the unary example

* Server
{% raw %}
```
(deftype Greeter []
  greeter/Service
  (SayRepeatHello
    [this {{:keys [name]} :grpc-params :as request}]
    (let [resp-chan (:grpc-out request)]
      (go
        (dotimes [_ 3]
          (>! resp-chan {:message (str "Hello, " name)}))
        (async/close! resp-chan))
      {:status 200
       :body resp-chan})))
```
{% endraw %}


#### Client Streaming Example
Identical to the above Client example for unary -- instead of closing the channels after pushing a single map,
keep the core.async channel open and push maps as needed.

See the streaming-grpc-check test in Protojure lib's [grpc_test.clj](https://github.com/protojure/lib/blob/master/test/protojure/grpc_test.clj)

Excerpt:

```
    (let [repetitions 50
          input (async/chan repetitions)
          output (async/chan repetitions)
          client (:grpc-client @test-env)
          desc {:service "example.hello.Greeter"
                :method "SayHelloOnDemand"
                :input {:f new-HelloRequest :ch input}
                :output {:f pb->HelloReply :ch output}}]

      (async/onto-chan input (repeat repetitions {:name "World"}))

      @(-> (grpc/invoke client desc)
```

#### Clojure Docs
* [Protojure lib cljdoc](https://cljdoc.org/d/protojure/protojure)

#### Contributing

We cannot (yet) accept outside contributions to the code base at this time. Please check for updates in the future regarding acceptance of outside contributions.
